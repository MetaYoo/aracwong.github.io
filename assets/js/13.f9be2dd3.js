(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{225:function(t,a,r){"use strict";r.r(a);var s=r(0),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"二叉搜索树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树"}},[t._v("#")]),t._v(" 二叉搜索树")]),t._v(" "),r("p",[t._v("二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。")]),t._v(" "),r("p",[r("a",{attrs:{href:"/img/bst.png"}},[t._v("满二叉搜索树")])]),t._v(" "),r("h2",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),r("p",[t._v("二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。\n中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。\n每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索,插入,删除的复杂度等于树高，O(log(n)).")]),t._v(" "),r("h2",{attrs:{id:"算法实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法实现"}},[t._v("#")]),t._v(" 算法实现")]),t._v(" "),r("h3",{attrs:{id:"_1-二叉排序树的查找算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-二叉排序树的查找算法"}},[t._v("#")]),t._v(" 1.二叉排序树的查找算法")]),t._v(" "),r("h3",{attrs:{id:"_2-在二叉排序树插入结点的算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-在二叉排序树插入结点的算法"}},[t._v("#")]),t._v(" 2.在二叉排序树插入结点的算法")]),t._v(" "),r("h3",{attrs:{id:"_3-在二叉排序树删除结点的算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-在二叉排序树删除结点的算法"}},[t._v("#")]),t._v(" 3.在二叉排序树删除结点的算法")]),t._v(" "),r("h3",{attrs:{id:"_4-二叉排序树性能分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-二叉排序树性能分析"}},[t._v("#")]),t._v(" 4.二叉排序树性能分析")])])}),[],!1,null,null,null);a.default=e.exports}}]);